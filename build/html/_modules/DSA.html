
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DSA &#8212; outlabq2  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for DSA</h1><div class="highlight"><pre>
<span></span><span class="c1">################################## Data Structures ################################</span>

<span class="c1"># ------------------------------- Singly Linked List -----------------------------</span>

<div class="viewcode-block" id="SinglyLinkedListNode"><a class="viewcode-back" href="../SLLN.html#DSA.SinglyLinkedListNode">[docs]</a><span class="k">class</span> <span class="nc">SinglyLinkedListNode</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; SinglyLinkedListNode</span>
<span class="sd">        Data structure for a singly linked list node</span>
<span class="sd">        Has two member variables:</span>

<span class="sd">        1. data (to store data)</span>
<span class="sd">        2. next (pointer to next node)</span>

<span class="sd">        | Has one constructors and one converter:</span>
<span class="sd">        | __init__(self, data)</span>
<span class="sd">        | __str__(self)</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SinglyLinkedListNode.__init__"><a class="viewcode-back" href="../SLLN.html#DSA.SinglyLinkedListNode.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Default constructor for a linked list node</span>

<span class="sd">        :param data: The data to be stored</span>
<span class="sd">        :param next: Pointer to the next node</span>

<span class="sd">        &gt;&gt;&gt; from DSA import SinglyLinkedListNode</span>
<span class="sd">        &gt;&gt;&gt; a = 65</span>
<span class="sd">        &gt;&gt;&gt; node = SinglyLinkedListNode(a)</span>
<span class="sd">        &gt;&gt;&gt; print(node.data)</span>
<span class="sd">        65</span>
<span class="sd">        &gt;&gt;&gt; print(type(node.data))</span>
<span class="sd">        &lt;class &#39;int&#39;&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kc">None</span></div>
    
<div class="viewcode-block" id="SinglyLinkedListNode.__str__"><a class="viewcode-back" href="../SLLN.html#DSA.SinglyLinkedListNode.__str__">[docs]</a>    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converter method which converts data stored in the</span>
<span class="sd">        node to a string and returns it</span>

<span class="sd">        &gt;&gt;&gt; print(str(node.data))</span>
<span class="sd">        65</span>
<span class="sd">        &gt;&gt;&gt; print(type(str(node.data)))</span>
<span class="sd">        &lt;class &#39;str&#39;&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="SinglyLinkedList"><a class="viewcode-back" href="../SLL.html#DSA.SinglyLinkedList">[docs]</a><span class="k">class</span> <span class="nc">SinglyLinkedList</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Data structure of the singly linked list</span>

<span class="sd">    | Contains two pointers, head and tail and member variables, pointing to linked list nodes</span>
<span class="sd">    | Contains the following member functions:</span>

<span class="sd">    * __init__(self)</span>
<span class="sd">    * insert(self, data)</span>
<span class="sd">    * find(self, data)</span>
<span class="sd">    * deleteVal(self, data)</span>
<span class="sd">    * printer(self, sep = &#39;, &#39;)</span>
<span class="sd">    * reverse(self)</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SinglyLinkedList.__init__"><a class="viewcode-back" href="../SLL.html#DSA.SinglyLinkedList.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Constructor for the Singly Linked List, sets the head and tail to None</span>

<span class="sd">        &gt;&gt;&gt; from DSA import SinglyLinkedList</span>
<span class="sd">        &gt;&gt;&gt; L = SinglyLinkedList()</span>
<span class="sd">        &gt;&gt;&gt; print(L.head)</span>
<span class="sd">        None</span>
<span class="sd">        &gt;&gt;&gt; print(L.tail)</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="kc">None</span></div>
   
<div class="viewcode-block" id="SinglyLinkedList.insert"><a class="viewcode-back" href="../SLL.html#DSA.SinglyLinkedList.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Insert function, inserts nodes into the linked list, storing the data</span>

<span class="sd">        :param data: The data to be stored in the linked list</span>

<span class="sd">        &gt;&gt;&gt; L.insert(10)</span>
<span class="sd">        &gt;&gt;&gt; L.insert(12)</span>
<span class="sd">        &gt;&gt;&gt; L.insert(25)</span>
<span class="sd">        &gt;&gt;&gt; print(L.head)</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; print(L.tail)</span>
<span class="sd">        25</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">SinglyLinkedListNode</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="c1"># new node</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">:</span> <span class="c1"># no head</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span> <span class="c1"># add behind tail</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">node</span> <span class="c1"># move tail</span></div>
    
<div class="viewcode-block" id="SinglyLinkedList.find"><a class="viewcode-back" href="../SLL.html#DSA.SinglyLinkedList.find">[docs]</a>    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Finds if a value is stored in the linked list or not</span>

<span class="sd">        :param data: The value to be found in the linked list</span>
<span class="sd">        :return: The previous node, if the first node is to be found, returns None, and if the value is not in the list, returns the last node</span>
<span class="sd">        :rtype: SinglyLinkedListNode or Nonetype</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; print(L.find(10))</span>
<span class="sd">        None</span>
<span class="sd">        &gt;&gt;&gt; print(L.find(12))</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; print(L.find(25))</span>
<span class="sd">        12</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">while</span> <span class="n">head</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">head</span><span class="o">.</span><span class="n">data</span> <span class="o">!=</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">head</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>
        <span class="k">return</span> <span class="n">prev</span></div>
    
<div class="viewcode-block" id="SinglyLinkedList.deleteVal"><a class="viewcode-back" href="../SLL.html#DSA.SinglyLinkedList.deleteVal">[docs]</a>    <span class="k">def</span> <span class="nf">deleteVal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deletes values from the linked list</span>

<span class="sd">        :param data: The value to be deleted</span>
<span class="sd">        :returns: True, if the value was successfully deleted, otherwise False</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        &gt;&gt;&gt; L = SinglyLinkedList()</span>
<span class="sd">        &gt;&gt;&gt; L.insert(10)</span>
<span class="sd">        &gt;&gt;&gt; L.insert(12)</span>
<span class="sd">        &gt;&gt;&gt; L.insert(25)</span>
<span class="sd">        &gt;&gt;&gt; L.deleteVal(13) </span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; L.deleteVal(25)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prevPos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">prevPos</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">prevPos</span><span class="o">.</span><span class="n">next</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">prevPos</span><span class="o">.</span><span class="n">next</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">prevPos</span><span class="o">.</span><span class="n">next</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">prevPos</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">prevPos</span><span class="o">.</span><span class="n">next</span>
        <span class="k">return</span> <span class="kc">True</span></div>
    
<div class="viewcode-block" id="SinglyLinkedList.printer"><a class="viewcode-back" href="../SLL.html#DSA.SinglyLinkedList.printer">[docs]</a>    <span class="k">def</span> <span class="nf">printer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;, &#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prints the Linked List</span>

<span class="sd">        :param sep: The separator will be printed in between the values in the linked list</span>

<span class="sd">        &gt;&gt;&gt; L = SinglyLinkedList()</span>
<span class="sd">        &gt;&gt;&gt; L.insert(10)</span>
<span class="sd">        &gt;&gt;&gt; L.insert(12)</span>
<span class="sd">        &gt;&gt;&gt; L.insert(25)</span>
<span class="sd">        &gt;&gt;&gt; L.printer(&#39;:&#39;)</span>
<span class="sd">        [10:12:25]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">ptr</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="n">next</span>
            <span class="k">if</span> <span class="n">ptr</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;]&#39;</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="SinglyLinkedList.reverse"><a class="viewcode-back" href="../SLL.html#DSA.SinglyLinkedList.reverse">[docs]</a>    <span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reverses the whole linked list</span>

<span class="sd">        &gt;&gt;&gt; L = SinglyLinkedList()</span>
<span class="sd">        &gt;&gt;&gt; L.insert(10)</span>
<span class="sd">        &gt;&gt;&gt; L.insert(12)</span>
<span class="sd">        &gt;&gt;&gt; L.insert(25)</span>
<span class="sd">        &gt;&gt;&gt; L.printer()</span>
<span class="sd">        [10, 12, 25]</span>
<span class="sd">        &gt;&gt;&gt; L.reverse()</span>
<span class="sd">        &gt;&gt;&gt; L.printer()</span>
<span class="sd">        [25, 12, 10]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="c1"># head pointer</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># previous pointer</span>
        <span class="k">while</span> <span class="n">head</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># while there is forward link left</span>
            <span class="n">newHead</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="c1"># save extra pointer to next element</span>
            <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">prev</span> <span class="c1"># reverse the link of current element</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">head</span> <span class="c1"># move pointer to previous element</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">newHead</span> <span class="c1"># use extra pointer to move to next element</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">prev</span></div></div>

<div class="viewcode-block" id="merge"><a class="viewcode-back" href="../DSA.html#DSA.merge">[docs]</a><span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Merges two linked lists together</span>

<span class="sd">    :param list1: The first list to be merged</span>
<span class="sd">    :param list2: The second list to be merged</span>
<span class="sd">    :return: Returns the merged Linked list</span>
<span class="sd">    :rtype: SinglyLinkedList</span>

<span class="sd">    &gt;&gt;&gt; from DSA import merge, SinglyLinkedList</span>
<span class="sd">    &gt;&gt;&gt; L1 = SinglyLinkedList()</span>
<span class="sd">    &gt;&gt;&gt; L1.insert(10)</span>
<span class="sd">    &gt;&gt;&gt; L1.insert(12)</span>
<span class="sd">    &gt;&gt;&gt; L1.insert(25)</span>
<span class="sd">    &gt;&gt;&gt; L1.printer()</span>
<span class="sd">    [10, 12, 25]</span>
<span class="sd">    &gt;&gt;&gt; L2 = SinglyLinkedList()</span>
<span class="sd">    &gt;&gt;&gt; L2.insert(67)</span>
<span class="sd">    &gt;&gt;&gt; L2.insert(100)</span>
<span class="sd">    &gt;&gt;&gt; L2.insert(26)</span>
<span class="sd">    &gt;&gt;&gt; L2.printer()</span>
<span class="sd">    [67, 100, 26]</span>
<span class="sd">    &gt;&gt;&gt; L3 = merge(L1, L2)</span>
<span class="sd">    &gt;&gt;&gt; L3.printer()</span>
<span class="sd">    [10, 12, 25, 67, 100, 26]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="n">SinglyLinkedList</span><span class="p">()</span>
    <span class="n">head1</span> <span class="o">=</span> <span class="n">list1</span><span class="o">.</span><span class="n">head</span>
    <span class="n">head2</span> <span class="o">=</span> <span class="n">list2</span><span class="o">.</span><span class="n">head</span>
    <span class="k">while</span> <span class="n">head1</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">head2</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># both lists not empty</span>
        <span class="k">if</span> <span class="n">head1</span><span class="o">.</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">head2</span><span class="o">.</span><span class="n">data</span><span class="p">:</span> <span class="c1"># link node with smaller data</span>
            <span class="n">merged</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">head1</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="n">head1</span> <span class="o">=</span> <span class="n">head1</span><span class="o">.</span><span class="n">next</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">merged</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">head2</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="n">head2</span> <span class="o">=</span> <span class="n">head2</span><span class="o">.</span><span class="n">next</span>
    <span class="k">if</span> <span class="n">head1</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">head2</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># list 1 finished</span>
        <span class="n">merged</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">head2</span> <span class="c1"># add remaining list 2 as is</span>
    <span class="k">if</span> <span class="n">head1</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">head2</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># list 2 finished</span>
        <span class="n">merged</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">head1</span> <span class="c1"># add remaining list 1 as is</span>
    <span class="k">return</span> <span class="n">merged</span></div>

<span class="c1"># ------------------------------ Doubly Linked List ----------------------------</span>

<div class="viewcode-block" id="DoublyLinkedListNode"><a class="viewcode-back" href="../DLLN.html#DSA.DoublyLinkedListNode">[docs]</a><span class="k">class</span> <span class="nc">DoublyLinkedListNode</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; DoublyLinkedListNode</span>
<span class="sd">        Data structure for a Doubly linked list node</span>

<span class="sd">        | Has two member variables:</span>
<span class="sd">        | data (to store data)</span>
<span class="sd">        | next (pointer to next node)</span>
<span class="sd">        | prev (pointer to the previous node)</span>

<span class="sd">        | Has one constructors and one converter:</span>
<span class="sd">        | __init__(self, data)</span>
<span class="sd">        | __str__(self)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="DoublyLinkedListNode.__init__"><a class="viewcode-back" href="../DLLN.html#DSA.DoublyLinkedListNode.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Default constructor for a linked list node</span>

<span class="sd">        :param data: The data to be stored</span>
<span class="sd">        :param next: Pointer to the next node</span>
<span class="sd">        :param prev: Pointer to the previous node</span>

<span class="sd">        &gt;&gt;&gt; from DSA import DoublyLinkedListNode</span>
<span class="sd">        &gt;&gt;&gt; a = 65</span>
<span class="sd">        &gt;&gt;&gt; node = DoublyLinkedListNode(a)</span>
<span class="sd">        &gt;&gt;&gt; print(node.data)</span>
<span class="sd">        65</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span></div>
    
<div class="viewcode-block" id="DoublyLinkedListNode.__str__"><a class="viewcode-back" href="../DLLN.html#DSA.DoublyLinkedListNode.__str__">[docs]</a>    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converter method which converts data stored in the</span>
<span class="sd">        node to a string and returns it</span>

<span class="sd">        &gt;&gt;&gt; print(str(node.data))</span>
<span class="sd">        65</span>
<span class="sd">        &gt;&gt;&gt; print(type(str(node.data)))</span>
<span class="sd">        &lt;class &#39;str&#39;&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> </div></div>

<div class="viewcode-block" id="DoublyLinkedList"><a class="viewcode-back" href="../DLL.html#DSA.DoublyLinkedList">[docs]</a><span class="k">class</span> <span class="nc">DoublyLinkedList</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Data structure of the Doubly linked list</span>

<span class="sd">    | Contains two pointers, head and tail and member variables, pointing to linked list nodes</span>
<span class="sd">    | Contains the following member functions:</span>
<span class="sd">    | __init__(self)</span>
<span class="sd">    | insert(self, data)</span>
<span class="sd">    | printer(self, sep = &#39;, &#39;)</span>
<span class="sd">    | reverse(self)</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="DoublyLinkedList.__init__"><a class="viewcode-back" href="../DLL.html#DSA.DoublyLinkedList.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Constructor for the Singly Linked List, sets the head and tail to None</span>

<span class="sd">        &gt;&gt;&gt; from DSA import DoublyLinkedList</span>
<span class="sd">        &gt;&gt;&gt; L = DoublyLinkedList()</span>
<span class="sd">        &gt;&gt;&gt; print(L.head)</span>
<span class="sd">        None</span>
<span class="sd">        &gt;&gt;&gt; print(L.tail)</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="kc">None</span></div>
    
<div class="viewcode-block" id="DoublyLinkedList.insert"><a class="viewcode-back" href="../DLL.html#DSA.DoublyLinkedList.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Insert function, inserts nodes into the linked list, storing the data</span>

<span class="sd">        :param data: The data to be stored in the linked list</span>

<span class="sd">        &gt;&gt;&gt; L.insert(10)</span>
<span class="sd">        &gt;&gt;&gt; L.insert(12)</span>
<span class="sd">        &gt;&gt;&gt; L.insert(25)</span>
<span class="sd">        &gt;&gt;&gt; print(L.head)</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; print(L.tail)</span>
<span class="sd">        25</span>
<span class="sd">        &gt;&gt;&gt; L.insert(26)</span>
<span class="sd">        &gt;&gt;&gt; print(L.tail)</span>
<span class="sd">        26</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">DoublyLinkedListNode</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="c1"># new node</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">:</span> <span class="c1"># no head</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span> <span class="c1"># add behind tail</span>
            <span class="n">node</span><span class="o">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tail</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">node</span> <span class="c1"># move tail</span></div>
    
<div class="viewcode-block" id="DoublyLinkedList.printer"><a class="viewcode-back" href="../DLL.html#DSA.DoublyLinkedList.printer">[docs]</a>    <span class="k">def</span> <span class="nf">printer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;, &#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prints the Linked List</span>

<span class="sd">        :param sep: The separator will be printed in between the values in the linked list</span>

<span class="sd">        &gt;&gt;&gt; L.printer(&#39;:&#39;)</span>
<span class="sd">        [10:12:25:26]</span>
<span class="sd">        &gt;&gt;&gt; L.insert(27)</span>
<span class="sd">        &gt;&gt;&gt; L.printer()</span>
<span class="sd">        [10, 12, 25, 26, 27]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">ptr</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="n">next</span>
            <span class="k">if</span> <span class="n">ptr</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;]&#39;</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="DoublyLinkedList.reverse"><a class="viewcode-back" href="../DLL.html#DSA.DoublyLinkedList.reverse">[docs]</a>    <span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reverses the whole linked list</span>

<span class="sd">        &gt;&gt;&gt; L.printer()</span>
<span class="sd">        [10, 12, 25, 26, 27]</span>
<span class="sd">        &gt;&gt;&gt; L.reverse()</span>
<span class="sd">        &gt;&gt;&gt; L.printer()</span>
<span class="sd">        [27, 26, 25, 12, 10]</span>
<span class="sd">        &gt;&gt;&gt; L.insert(34)</span>
<span class="sd">        &gt;&gt;&gt; L.reverse()</span>
<span class="sd">        &gt;&gt;&gt; L.printer()</span>
<span class="sd">        [34, 10, 12, 25, 26, 27]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="c1"># head pointer</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># previous pointer</span>
        <span class="k">while</span> <span class="n">head</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># new node left</span>
            <span class="n">newHead</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="c1"># save pointer to next node (cut forward link)</span>
            <span class="k">if</span> <span class="n">newHead</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># check if next node has a reverse link</span>
                <span class="n">newHead</span><span class="o">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">head</span> <span class="c1"># save pointer to previous node (cut reverse link)</span>
            <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">prev</span> <span class="c1"># reverse the forward link</span>
            <span class="n">head</span><span class="o">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">newHead</span> <span class="c1"># reverse the reverse link</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">head</span> <span class="c1"># move pointer to previous element</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">newHead</span> <span class="c1"># use saved pointer to move head</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">prev</span></div></div>

<span class="c1"># -------------------------- Binary Search Tree ------------------------------</span>


<div class="viewcode-block" id="BSTNode"><a class="viewcode-back" href="../BSTN.html#DSA.BSTNode">[docs]</a><span class="k">class</span> <span class="nc">BSTNode</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Data Structure for a Binary Search Tree Node</span>

<span class="sd">    | The member variables are:</span>
<span class="sd">    | info</span>
<span class="sd">    | level (storing the data and the level of the node)</span>
<span class="sd">    | left (pointer to left child)</span>
<span class="sd">    | right (pointer to right child)</span>
<span class="sd">    </span>
<span class="sd">    | The member functions are:</span>
<span class="sd">    | __init__(self, info)</span>
<span class="sd">    | __str__(self)</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="BSTNode.__init__"><a class="viewcode-back" href="../BSTN.html#DSA.BSTNode.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor for BSTNode, initialises the data stored in the node,</span>
<span class="sd">        the pointers left and right are made None, and the level is set to None</span>

<span class="sd">        &gt;&gt;&gt; from DSA import BSTNode</span>
<span class="sd">        &gt;&gt;&gt; node = BSTNode(69)</span>
<span class="sd">        &gt;&gt;&gt; print(node.info)</span>
<span class="sd">        69</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="kc">None</span></div>
    
<div class="viewcode-block" id="BSTNode.__str__"><a class="viewcode-back" href="../BSTN.html#DSA.BSTNode.__str__">[docs]</a>    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts the data stored in the node to a string</span>

<span class="sd">        :return: The data stored converted to string</span>
<span class="sd">        :rtype: string</span>

<span class="sd">        &gt;&gt;&gt; print(str(node))</span>
<span class="sd">        69</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="BinarySearchTree"><a class="viewcode-back" href="../BST.html#DSA.BinarySearchTree">[docs]</a><span class="k">class</span> <span class="nc">BinarySearchTree</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Data Structure of a Binary Search Tree</span>



<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="BinarySearchTree.__init__"><a class="viewcode-back" href="../BST.html#DSA.BinarySearchTree.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor of the BinarySearchTree, sets the root to None</span>

<span class="sd">        &gt;&gt;&gt; from DSA import BinarySearchTree</span>
<span class="sd">        &gt;&gt;&gt; tree = BinarySearchTree()</span>
<span class="sd">        &gt;&gt;&gt; print(tree.root)</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="kc">None</span></div>
    
<div class="viewcode-block" id="BinarySearchTree.insert"><a class="viewcode-back" href="../BST.html#DSA.BinarySearchTree.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Insert data into the BST</span>

<span class="sd">        :param val: The value to be inserted in the BST</span>

<span class="sd">        &gt;&gt;&gt; tree.insert(10)</span>
<span class="sd">        &gt;&gt;&gt; tree.insert(4)</span>
<span class="sd">        &gt;&gt;&gt; tree.insert(24)</span>
<span class="sd">        &gt;&gt;&gt; print(tree.root)</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; print(tree.root.left)</span>
<span class="sd">        4</span>
<span class="sd">        &gt;&gt;&gt; print(tree.root.right)</span>
<span class="sd">        24</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">BSTNode</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">.</span><span class="n">info</span><span class="p">:</span> <span class="c1"># move to left sub-tree</span>
                    <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">left</span> <span class="c1"># root moved</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">current</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">BSTNode</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="c1"># left init</span>
                        <span class="k">break</span>
                <span class="k">elif</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">current</span><span class="o">.</span><span class="n">info</span><span class="p">:</span> <span class="c1"># move to right sub-tree</span>
                    <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">right</span> <span class="c1"># root moved</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">current</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">BSTNode</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="c1"># right init</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span> <span class="c1"># value exists</span></div>
    
<div class="viewcode-block" id="BinarySearchTree.traverse"><a class="viewcode-back" href="../BST.html#DSA.BinarySearchTree.traverse">[docs]</a>    <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Traverses the tree in the given order and prints it out</span>

<span class="sd">        :param order: Specifies the order in which the tree is to be traversed, can be PRE, IN or POST</span>

<span class="sd">        &gt;&gt;&gt; tree.traverse(&#39;PRE&#39;)</span>
<span class="sd">        10 4 24 </span>
<span class="sd">        &gt;&gt;&gt; tree.traverse(&#39;POST&#39;)</span>
<span class="sd">        4 24 10 </span>
<span class="sd">        &gt;&gt;&gt; tree.traverse(&#39;IN&#39;)</span>
<span class="sd">        4 10 24 </span>
<span class="sd">        &gt;&gt;&gt; tree.insert(64)</span>
<span class="sd">        &gt;&gt;&gt; tree.traverse(&#39;POST&#39;) # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        4 64 24 10</span>
<span class="sd">        &gt;&gt;&gt; tree.insert(20)</span>
<span class="sd">        &gt;&gt;&gt; tree.traverse(&#39;PRE&#39;) # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        10 4 24 20 64</span>

<span class="sd">        Note that in the first few traversals, I have manually added a trailing whitespace, alternatively</span>
<span class="sd">        doctest flags can also be used as shown</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">preOrder</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">preOrder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">preOrder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">inOrder</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">inOrder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">inOrder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">postOrder</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">postOrder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">postOrder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s1">&#39;PRE&#39;</span><span class="p">:</span>
            <span class="n">preOrder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="s1">&#39;IN&#39;</span><span class="p">:</span>
            <span class="n">inOrder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="s1">&#39;POST&#39;</span><span class="p">:</span>
            <span class="n">postOrder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="BinarySearchTree.height"><a class="viewcode-back" href="../BST.html#DSA.BinarySearchTree.height">[docs]</a>    <span class="k">def</span> <span class="nf">height</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gives the height of the tree</span>

<span class="sd">        :param root: The node from which height is to be found</span>
<span class="sd">        :return: The height of the tree from the given node</span>
<span class="sd">        :rtype: int</span>

<span class="sd">        &gt;&gt;&gt; node = tree.root</span>
<span class="sd">        &gt;&gt;&gt; print(tree.height(node))</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; print(tree.height(node.left))</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; tree.insert(29)</span>
<span class="sd">        &gt;&gt;&gt; print(tree.height(node))</span>
<span class="sd">        3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">))</span></div></div>

<span class="c1"># --------------------------------- Suffix Trie --------------------------------</span>

<div class="viewcode-block" id="Trie"><a class="viewcode-back" href="../Trie.html#DSA.Trie">[docs]</a><span class="k">class</span> <span class="nc">Trie</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Data Structure of a Trie</span>

<span class="sd">    | Has member variables:</span>
<span class="sd">    | count</span>
<span class="sd">    | nodes</span>

<span class="sd">    | Has the following member functions:</span>
<span class="sd">    | __init__(self)</span>
<span class="sd">    | find(self, root, c)</span>
<span class="sd">    | insert(self, s)</span>
<span class="sd">    | checkPrefix(self, s)</span>
<span class="sd">    | countPrefix(self, s)</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Trie.__init__"><a class="viewcode-back" href="../Trie.html#DSA.Trie.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor of Trie, creates an empty Trie</span>

<span class="sd">        &gt;&gt;&gt; from DSA import Trie</span>
<span class="sd">        &gt;&gt;&gt; t = Trie()</span>
<span class="sd">        &gt;&gt;&gt; print(t.T)</span>
<span class="sd">        {}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="p">{}</span></div>
    
<div class="viewcode-block" id="Trie.find"><a class="viewcode-back" href="../Trie.html#DSA.Trie.find">[docs]</a>    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Finds whether the node correctly corresponds to the character</span>

<span class="sd">        :param root: A node of the trie whose character is to be checked</span>
<span class="sd">        :param c: The character to be checked</span>
<span class="sd">        :return: True if they match, else False</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        &gt;&gt;&gt; t.insert(&#39;banana&#39;)</span>
<span class="sd">        &gt;&gt;&gt; root = t.T</span>
<span class="sd">        &gt;&gt;&gt; print(t.find(root, &#39;a&#39;))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; print(t.find(root, &#39;b&#39;))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; print(t.find(root[&#39;b&#39;], &#39;b&#39;))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; print(t.find(root[&#39;b&#39;], &#39;a&#39;))</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">c</span> <span class="ow">in</span> <span class="n">root</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Trie.insert"><a class="viewcode-back" href="../Trie.html#DSA.Trie.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inserts a word in the Trie</span>
<span class="sd">        :param s: The string to be inserted in the trie</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; t.insert(&#39;cat&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(t.find(root, &#39;a&#39;))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; print(t.find(root, &#39;b&#39;))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; print(t.find(root, &#39;c&#39;))</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">c</span><span class="p">):</span>
                <span class="n">root</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="n">root</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">root</span><span class="p">[</span><span class="s1">&#39;#&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span></div>
    
<div class="viewcode-block" id="Trie.checkPrefix"><a class="viewcode-back" href="../Trie.html#DSA.Trie.checkPrefix">[docs]</a>    <span class="k">def</span> <span class="nf">checkPrefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if a word is a prefix of any word stored in the Trie</span>

<span class="sd">        :param s: The prefix to be checked</span>
<span class="sd">        :return: If the string is a prefix, then True, else False</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        &gt;&gt;&gt; print(t.checkPrefix(&#39;ca&#39;))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; print(t.checkPrefix(&#39;ban&#39;))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; print(t.checkPrefix(&#39;bac&#39;))</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">char</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>    
                    <span class="n">root</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;#&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">root</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">elif</span> <span class="n">root</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;#&#39;</span> <span class="ow">or</span> <span class="n">idx</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="n">char</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">False</span></div>
    
<div class="viewcode-block" id="Trie.countPrefix"><a class="viewcode-back" href="../Trie.html#DSA.Trie.countPrefix">[docs]</a>    <span class="k">def</span> <span class="nf">countPrefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; counts the number of words which have a string as the prefix</span>

<span class="sd">        :param s: The prefix to be checked</span>
<span class="sd">        :return: The number of times the prefix appears</span>
<span class="sd">        :rtype: int</span>

<span class="sd">        &gt;&gt;&gt; print(t.countPrefix(&#39;ba&#39;))</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; t.insert(&#39;basketball&#39;)</span>
<span class="sd">        &gt;&gt;&gt; t.insert(&#39;bandicam&#39;)</span>
<span class="sd">        &gt;&gt;&gt; t.insert(&#39;bat&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(t.countPrefix(&#39;ba&#39;))</span>
<span class="sd">        4</span>
<span class="sd">        &gt;&gt;&gt; print(t.countPrefix(&#39;ban&#39;))</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">c</span><span class="p">):</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">found</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root</span><span class="p">[</span><span class="s1">&#39;#&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="mi">0</span></div></div>

<span class="c1"># --------------------------------------Heap------------------------------------</span>

<div class="viewcode-block" id="Heap"><a class="viewcode-back" href="../Heap.html#DSA.Heap">[docs]</a><span class="k">class</span> <span class="nc">Heap</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; This Heap class is  a specialized tree-based data structure which is essentially an almost complete</span>
<span class="sd">    tree that satisfies the heap property: in a max heap, for any given node C, if P is a parent node of C,</span>
<span class="sd">    then the key (the value) of P is greater than or equal to the key of C. In a min heap, the key of P is</span>
<span class="sd">    less than or equal to the key of C.</span>

<span class="sd">    | The node at the &quot;top&quot; of the heap (with no parents) is called the root node. </span>
<span class="sd">    | The functions in the class are:</span>

<span class="sd">    - __init__(self, cap)</span>
<span class="sd">    - parent(self, i)</span>
<span class="sd">    - left(self, i)</span>
<span class="sd">    - right(self, i)</span>
<span class="sd">    - insert(self, val)</span>
<span class="sd">    - min(self)</span>
<span class="sd">    - Heapify(self, root)</span>
<span class="sd">    - deleteMin(self)</span>

<span class="sd">      &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Heap.__init__"><a class="viewcode-back" href="../Heap.html#DSA.Heap.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cap</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Constructor for adding nodes in the heap</span>

<span class="sd">        :param cap: The value to be stored in the heap</span>
<span class="sd">        :type cap: numeric</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; from DSA import Heap</span>
<span class="sd">        &gt;&gt;&gt; heap = Heap(10)</span>
<span class="sd">        &gt;&gt;&gt; print(heap.M)</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; print(heap.n)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; print(heap.H)</span>
<span class="sd">        []</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="n">cap</span></div>
    
<div class="viewcode-block" id="Heap.parent"><a class="viewcode-back" href="../Heap.html#DSA.Heap.parent">[docs]</a>    <span class="k">def</span> <span class="nf">parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Finds parent of a node</span>

<span class="sd">        :param i: The index of the node to find the parent of</span>
<span class="sd">        :type i: int</span>
<span class="sd">        :return: Returns the index of the parent</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; heap.insert(5)</span>
<span class="sd">        &gt;&gt;&gt; heap.insert(2)</span>
<span class="sd">        &gt;&gt;&gt; heap.insert(12)</span>
<span class="sd">        &gt;&gt;&gt; heap.insert(29)</span>
<span class="sd">        &gt;&gt;&gt; print(heap.H)</span>
<span class="sd">        [2, 5, 12, 29]</span>
<span class="sd">        &gt;&gt;&gt; print(heap.parent(1))</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; print(heap.parent(3))</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span></div>
    
<div class="viewcode-block" id="Heap.left"><a class="viewcode-back" href="../Heap.html#DSA.Heap.left">[docs]</a>    <span class="k">def</span> <span class="nf">left</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Finds left child of a node</span>

<span class="sd">        :param i: The index of the node to find the left of</span>
<span class="sd">        :type i: int</span>
<span class="sd">        :return: Returns the index of the left child</span>
<span class="sd">        :rtype: int</span>

<span class="sd">        &gt;&gt;&gt; print(heap.left(0))</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; print(heap.left(1))</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; heap.insert(22)</span>
<span class="sd">        &gt;&gt;&gt; heap.insert(43)</span>
<span class="sd">        &gt;&gt;&gt; print(heap.left(2))</span>
<span class="sd">        5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></div>
    
<div class="viewcode-block" id="Heap.right"><a class="viewcode-back" href="../Heap.html#DSA.Heap.right">[docs]</a>    <span class="k">def</span> <span class="nf">right</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Finds right child of a node</span>

<span class="sd">        :param i: The index of the node to find the right of</span>
<span class="sd">        :type i: int</span>
<span class="sd">        :return: Returns the index of the right child</span>
<span class="sd">        :rtype: int</span>

<span class="sd">        &gt;&gt;&gt; print(heap.right(0))</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; print(heap.right(1))</span>
<span class="sd">        4</span>
<span class="sd">        &gt;&gt;&gt; heap.insert(22)</span>
<span class="sd">        &gt;&gt;&gt; heap.insert(43)</span>
<span class="sd">        &gt;&gt;&gt; heap.insert(56)</span>
<span class="sd">        &gt;&gt;&gt; print(heap.right(2))</span>
<span class="sd">        6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Heap.insert"><a class="viewcode-back" href="../Heap.html#DSA.Heap.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inserts new value in the heap</span>

<span class="sd">        :param val: new value to be inserted</span>
<span class="sd">        :type val: numeric</span>

<span class="sd">        &gt;&gt;&gt; from DSA import Heap</span>
<span class="sd">        &gt;&gt;&gt; heap = Heap(10)</span>
<span class="sd">        &gt;&gt;&gt; heap.insert(5)</span>
<span class="sd">        &gt;&gt;&gt; heap.insert(2)</span>
<span class="sd">        &gt;&gt;&gt; heap.insert(12)</span>
<span class="sd">        &gt;&gt;&gt; heap.insert(29)</span>
<span class="sd">        &gt;&gt;&gt; print(heap.H)</span>
<span class="sd">        [2, 5, 12, 29]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">i</span><span class="p">)],</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">i</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Heap.min"><a class="viewcode-back" href="../Heap.html#DSA.Heap.min">[docs]</a>    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Finds min value in the heap</span>

<span class="sd">        :return: The min value stored, if the heap is non empty, else returns -1</span>
<span class="sd">        :rtype: int</span>

<span class="sd">        &gt;&gt;&gt; print(heap.min())</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; heap.insert(1)</span>
<span class="sd">        &gt;&gt;&gt; print(heap.min())</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span></div>
    
<div class="viewcode-block" id="Heap.Heapify"><a class="viewcode-back" href="../Heap.html#DSA.Heap.Heapify">[docs]</a>    <span class="k">def</span> <span class="nf">Heapify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs self adjustment when the heap property is violated on addition of new values</span>

<span class="sd">        :param root: Root of the heap</span>
<span class="sd">        :type root: int</span>

<span class="sd">        | We&#39;ll purposely modify the list incorrectly and then heapify will correct it. </span>

<span class="sd">        &gt;&gt;&gt; print(heap.H)</span>
<span class="sd">        [1, 2, 12, 29, 5]</span>
<span class="sd">        &gt;&gt;&gt; temp = heap.H[0]</span>
<span class="sd">        &gt;&gt;&gt; heap.H[0] = heap.H[4]</span>
<span class="sd">        &gt;&gt;&gt; heap.H[4] = temp</span>
<span class="sd">        &gt;&gt;&gt; print(heap.H)</span>
<span class="sd">        [5, 2, 12, 29, 1]</span>
<span class="sd">        &gt;&gt;&gt; heap.Heapify(0)</span>
<span class="sd">        &gt;&gt;&gt; print(heap.H)</span>
<span class="sd">        [2, 1, 12, 29, 5]</span>
<span class="sd">        &gt;&gt;&gt; heap.Heapify(0)</span>
<span class="sd">        &gt;&gt;&gt; print(heap.H)</span>
<span class="sd">        [1, 2, 12, 29, 5]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">root</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">root</span><span class="p">]):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">l</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">s</span><span class="p">]):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">r</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">root</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">root</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">root</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Heapify</span><span class="p">(</span><span class="n">s</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Heap.deleteMin"><a class="viewcode-back" href="../Heap.html#DSA.Heap.deleteMin">[docs]</a>    <span class="k">def</span> <span class="nf">deleteMin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deletes min value in the heap</span>

<span class="sd">        &gt;&gt;&gt; print(heap.H)</span>
<span class="sd">        [1, 2, 12, 29, 5]</span>
<span class="sd">        &gt;&gt;&gt; heap.deleteMin()</span>
<span class="sd">        &gt;&gt;&gt; print(heap.H)</span>
<span class="sd">        [2, 5, 12, 29, 5]</span>
<span class="sd">        &gt;&gt;&gt; heap.deleteMin()</span>
<span class="sd">        &gt;&gt;&gt; print(heap.H)</span>
<span class="sd">        [5, 29, 12, 29, 5]</span>

<span class="sd">        Note that the 0 and 1 at the end is technically deleted from the array, and as a new </span>
<span class="sd">        element is inserted, it will be replaced</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Heapify</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span></div></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">outlabq2</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">q2</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, 21d100006.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.2.0.post0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>